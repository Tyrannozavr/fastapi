from typing import Annotated

from fastapi import APIRouter, Path
from fastapi import Body
from fastapi import Query, Cookie, Header
from pydantic import BaseModel, Field

from tools.docs.users_docs import validate_user1_docs
from types import UserIn, UserOut
from schemas.query import FilterParams

router = APIRouter()


@router.get("/parameters/{route}/")
def test_parameters(route: str, query: Annotated[str | None, Query(max_length=50)],
                    metadata: Annotated[str | None, Cookie(max_length=30)] = None):
    return f"route is {route}, query is {query} metadata is {metadata}"


@router.get("/impossible")
def test_parameters(query: Annotated[str | None, Query(max_length=5)] = "helloworld"):
    return f"query is {query}"


@router.get("/list")
def test_list_parameter(lst: Annotated[list[str], Query(title="test_title",
                                                        description="description for list parameter",
                                                        alias="hello-world-example", deprecated=True)],
                        test: Annotated[str | None, Query(include_in_schema=False)] = None):
    response = {"query items are": lst}
    if test:
        response["secret parameter is"] = test
    return response


@router.get("/bad_approach/{item_id}")
async def read_items(*, item_id: int = Path(title="The ID of the item to get"), q: str):
    """better with annotated"""
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results


@router.get("/number/validation/{number}")
def validate_number(number: Annotated[int, Path(ge=4, le=1000)], size: Annotated[float, Query(gt=0, lt=10.5)]):
    return f"number is {number} and size is {size}"


@router.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query


# This endpoint returns a 422 Unprocessable Entity error if:
# - first parameter is less than or equal to 100
# - second parameter is longer than 100 characters
# - last_one cookie value is less than 23 or has more than 2 digits
@router.post("/lots/params")
async def get_lots_params(first: Annotated[int, Query(ge=10)],
                          second: Annotated[str, Body(max_length=100, embed=True)], last_one:
        Annotated[str, Cookie()],
                          authentication: Annotated[str | None, Header()] = None):
    print(first, second, last_one)
    return f"first: {first} second: {second} Headers are: {authentication} and the cookie is {last_one}"


@router.get("/items/cookie/helloworld")
async def read_items(ads_id: Annotated[str | None, Cookie()] = None):
    """
    Auto generated curl works correct, but request made from given form in swagger ui doesn't really send cookie value
    \"Have in mind that, as browsers handle cookies in special ways and behind the scenes, they don't easily allow JavaScript to touch them.

If you go to the API docs UI at /docs you will be able to see the documentation for cookies for your path operations.

But even if you fill the data and click "Execute", because the docs UI works with JavaScript, the cookies won't be sent, and you will see an error message as if you didn't write any values.\"
    """
    print('id is', ads_id)
    return {"ads_id": ads_id}


@router.get("/multiple/values")
async def get_headers(x_token: Annotated[list[str], Header()] = None):
    return f"{x_token}"


class Cookies(BaseModel):
    first: str | None = Field(max_length=20, default=None)
    second_one: int | None = Field(default=None)
    third: int | None = Field(default=None)


class Response(BaseModel):
    message: str = Field()
    cookies: Cookies | None = Field(default=None)


@router.get("/cookie/test")
async def get_by_cookie(cookie: Annotated[Cookies | None, Cookie()] = None) -> Response:
    """Here even autogenerated curl isn't correct, so just made it by yourself
    Example curl:
    curl -X 'GET' \
      'http://127.0.0.1:8000/cookie/test' \
      -H 'accept: application/json' \
      -H 'Cookie: third=22; second_one=34; first="helloworld"'
    """
    if not cookie:
        cookie = ""
    response = Response(message=f"cookie is {cookie}")
    return response


class Cookies(BaseModel):
    first: str = Field(max_length=20)
    second_one: int = Field()
    third: int = Field()  # Removed max_digits which is invalid for int type



@router.post("/response/1")
async def validate_user(user: Annotated[UserIn, Body()]) -> UserOut:
    return UserOut(username=user.username, email=user.email)

@router.post("/response/2", **validate_user1_docs)
async def validate_user1(user: Annotated[UserIn, Body()]):
    """surprisingly the declaring of the response model just as union of types using vertical bar works correct
     python3.12.3"""
    if user.username == 'admin':
        return UserIn(**user.model_dump())
    return UserOut(**user.model_dump())

class BaseUser(BaseModel):
    username: str = Field(max_length=20)
    email: str = Field(max_length=20)


class SecondUserIn(BaseUser):
    password: str = Field(max_length=20)


@router.post("/response/3")
def validate_user3(user: Annotated[SecondUserIn, Body()]) -> BaseUser:
    return user


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@router.get("/items/exclude/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]
